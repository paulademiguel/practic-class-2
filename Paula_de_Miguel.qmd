---
title: "Introduction to Low level R"
author: "Paula de Miguel"
format: html
editor: visual
---

### Types and classes

### Types

```{r}
typeof(1.5)
typeof("toto")
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```

What is a type ? In computer science, the way you can manipulate objects depends on objects type. If I manipulate a double (real numbers), I excepts the computer to provide me with usual operations on real numbers. 

Different types : 

-double -> real numbers
-integers -> integers when specified (if not specified it will be a double)
-character -> need to use libraries in R to do interesting with it
-logical -> TRUE or FALSE
-closure -> functions 
-list 

### Classes

Classes are your own types that you created on your computer, Types are your environment on your computer. 

```{r}
data(iris)
typeof(iris)
class(iris)
class(1L)
```

You can create a class from a list or a vector. 
What we have to understand is that we have operations that are available for types and that can be applied to classes. 

### Vectors

### Introduction 

Many things in R are vectors (and most of the other things are list)
A vector is a collection of values of the same type (possibly a single value)

```{r}
x <- 15.25
length(x)
x[1] #the way to access an element of a vector
length(length(x))
typeof(length(x))
```

```{r}
y <- c(1, 2, 18.5)
length(y)
y[3]
typeof(y)
```

The `c` function can be seen as a creation function or, more accurately, as a vector concatenation function. 

### Character vectors

This is not R strength (compared to python I think he said)

```{r}
z <- "Alice"
length(z)
```
The length of z is 1 because it is a vector of length 1. 

### Characters vectors

This is not R strength

```{r}
z <- "Alice"
length(z)
```

Salvation comes from the `stringr`package

```{r}
library(stringr)
```

```{r}
str_length(z)
```

```{r}
complicated <- "ðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜"
complicated
length(complicated)
str_length(complicated)
```

```{r}
some_values <- c("ðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜ðŸ˜˜")
some_values
length(some_values)  
str_length(some_values)  
```

### Indexingggg

```{r}
x <- c(6,4,7,12,21,0)
x[3]
```

```{r}
x[5] <- 89
```

The following sets y to be not the same thing but basically a copy of x:

```{r}
y <- x
```

```{r}
x[2] <- 33
```

Modifying x doesn't impact y (unlike in python and other programming languages). 
It is called a lazy copy: saying x and y are the same (y <- x) they actually are the same. But when I call the modification of one of the elements of either of them, a copy is created for the purpose. 

```{r}
x
x[c(2,2,1,4,5)]
```

This puts the number associated with each of the position written in c from x itself. 

Assignmet can be understood has a value semantic assignment: `x``and `y`are different vectors with the 
```{r}
x(1) <- 18
x
y
```
indexing a vector is made vectors of any length

```{r}
x(0)
x(7)
```
```{r}
typeof(NA)
length(NA)
```
Concatenating vectors

```{r}
c(numeric(0), 5, numeric(0))
```
Vector must be type uniform, which will trigger 
```{r}
bar <- list(1L, 1.5, "toto", FALSE)
bar
```

